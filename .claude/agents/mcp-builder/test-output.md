# MCP Tool Architecture - Phase 3 Todo Chatbot
## Test Output from MCP Builder Subagent

> This document was generated by the MCP Builder subagent based on specs/phase3/spec.md
> Date: 2025-12-18
> Input: "Design MCP tools for Phase 3 Todo chatbot based on specs/phase3/spec.md"

---

## MCP Tool Architecture

### Overview
This MCP server provides conversational task management capabilities for the Todo AI Chatbot Phase 3. It exposes 5 tools that enable the OpenAI agent to perform all CRUD operations on user tasks through natural language commands. All tools are designed for stateless operation, enforce strict user isolation, and return structured data optimized for natural language response generation.

**Key Design Principles:**
- **User Isolation:** Every tool requires and validates user_id to prevent cross-user data access
- **Natural Language Friendly:** Return values include sufficient context for agent to craft conversational responses
- **Stateless Operation:** No session state maintained; all context derived from database
- **Error Transparency:** Clear error messages enable agent to provide helpful feedback to users

### Tool Catalog

| Tool Name | Purpose | Modifies Data | Auth Required | Idempotent | Complexity |
|-----------|---------|---------------|---------------|------------|------------|
| add_task | Create new task from natural language | Yes | Yes | No | Low |
| list_tasks | Retrieve tasks with filtering | No | Yes | Yes | Medium |
| update_task | Modify task title/description | Yes | Yes | No | Medium |
| delete_task | Remove task permanently | Yes | Yes | Yes | Low |
| complete_task | Toggle task completion status | Yes | Yes | Yes | Low |

**Estimated Implementation Time:** 8-12 hours for all tools + tests

---

### Tool: add_task

**Purpose:** Create a new task for the authenticated user from natural language input

**Parameters:**
- `user_id` (string, required) - User identifier from JWT token, used for authorization and data isolation
- `title` (string, required, 1-200 chars) - Task title extracted from user's natural language input
- `description` (string, optional, max 1000 chars) - Optional detailed description if user provides additional context

**Returns:**
- `task_id` (integer) - Unique identifier for the created task (used for subsequent operations)
- `status` (string: "created") - Operation status for agent to confirm action
- `title` (string) - Echo of task title for agent to construct confirmation message
- `description` (string|null) - Echo of description if provided (null if omitted)
- `completed` (boolean) - Always false for newly created tasks
- `created_at` (ISO 8601 datetime) - Timestamp of creation

**Validation Rules:**
- Title must not be empty string or contain only whitespace
- Title length: 1-200 characters (enforced at database level)
  - Rationale: UI displays first 50 chars; 200 is sufficient for most task descriptions
- Description length: 0-1000 characters if provided
  - Rationale: TEXT field can handle more, but 1000 chars is reasonable limit for task context
- user_id must exist in users table (foreign key constraint)
- Title and description must be sanitized to prevent XSS (escape HTML entities)
  - Rationale: Task content may be displayed in web UI

**Error Cases:**
- **ValidationError** (400): When title is empty, exceeds 200 chars, or is whitespace-only
  - Message format: "Title must be between 1 and 200 characters and cannot be empty"
- **ValidationError** (400): When description exceeds 1000 chars
  - Message format: "Description cannot exceed 1000 characters"
- **AuthorizationError** (401): When user_id from request doesn't match JWT token user_id
  - Message format: "User not authorized to perform this action"
- **ForeignKeyError** (400): When user_id doesn't exist in users table
  - Message format: "Invalid user_id: user does not exist"
- **DatabaseError** (500): When database write fails due to connection issues
  - Message format: "Unable to create task. Please try again."
  - Note: Safe to retry
- **RateLimitError** (429): When user exceeds 100 task creations per hour
  - Message format: "Rate limit exceeded. Please try again in {minutes} minutes."

**Example:**
```json
// Input - Basic task
{
  "user_id": "user_abc123",
  "title": "Buy groceries"
}

// Output
{
  "task_id": 42,
  "status": "created",
  "title": "Buy groceries",
  "description": null,
  "completed": false,
  "created_at": "2025-12-18T10:30:00Z"
}

// Agent Response (generated from output)
"I've added 'Buy groceries' to your task list."
```

```json
// Input - Task with description
{
  "user_id": "user_abc123",
  "title": "Prepare presentation for Monday",
  "description": "Include Q3 sales figures and market analysis"
}

// Output
{
  "task_id": 43,
  "status": "created",
  "title": "Prepare presentation for Monday",
  "description": "Include Q3 sales figures and market analysis",
  "completed": false,
  "created_at": "2025-12-18T10:35:00Z"
}

// Agent Response
"Got it! I've added 'Prepare presentation for Monday' to your tasks."
```

```json
// Error Example - Empty title
{
  "user_id": "user_abc123",
  "title": "   "
}

// Error Output
{
  "error": "ValidationError",
  "message": "Title must be between 1 and 200 characters and cannot be empty",
  "field": "title",
  "value": "   "
}

// Agent Response
"I couldn't create that task because the title cannot be empty. Can you describe what you'd like to do?"
```

**Security Notes:**
- **CRITICAL:** Verify user_id from request body matches JWT token user_id (enforced at API middleware level)
- Sanitize title and description using HTML entity escaping to prevent XSS attacks
  - Use library like `bleach` or `html.escape()` in Python
- Rate limiting: Max 100 task creations per user per hour to prevent abuse
  - Implement using Redis cache with sliding window algorithm
- Never allow client to specify task_id (auto-generated by database)
- Never allow client to set completed=true on creation (must use complete_task tool)
- Log all task creations with user_id and timestamp for audit trail

**Idempotency:** No - calling twice with identical inputs creates two separate tasks with different task_ids. This is intentional behavior (user may want duplicate tasks). If duplicate prevention is needed, consider adding optional idempotency_key parameter in future.

**Natural Language Integration Notes:**
- Agent should extract title from various phrasings:
  - "Add a task to buy groceries" → title="Buy groceries"
  - "I need to call the dentist" → title="Call the dentist"
  - "Remind me to submit the report" → title="Submit the report"
- Agent should detect and extract description from longer inputs:
  - "Add buy groceries with milk, eggs, and bread" → title="Buy groceries", description="milk, eggs, and bread"

---

### Tool: list_tasks

**Purpose:** Retrieve tasks for the authenticated user with optional filtering by completion status

**Parameters:**
- `user_id` (string, required) - User identifier from JWT token
- `status` (string, optional, enum: "all" | "pending" | "completed") - Filter by completion status
  - Default: "pending" (most common use case)
  - "all": Returns both completed and pending tasks
  - "pending": Returns only incomplete tasks (completed=false)
  - "completed": Returns only finished tasks (completed=true)
- `limit` (integer, optional, range: 1-100) - Maximum number of tasks to return
  - Default: 50
  - Rationale: Prevents excessive data transfer; 50 tasks is reasonable page size
- `offset` (integer, optional, min: 0) - Number of tasks to skip for pagination
  - Default: 0
- `sort_by` (string, optional, enum: "created_at" | "updated_at" | "title") - Field to sort by
  - Default: "created_at"
  - Rationale: Most recent tasks first is most useful for users
- `sort_order` (string, optional, enum: "asc" | "desc") - Sort direction
  - Default: "desc" (newest first)

**Returns:**
- `tasks` (array of Task objects) - List of tasks matching filters, sorted as specified
  - Each Task object contains:
    - `task_id` (integer) - Unique identifier
    - `title` (string) - Task title
    - `description` (string|null) - Task description or null if not set
    - `completed` (boolean) - Completion status
    - `created_at` (ISO 8601 datetime) - Creation timestamp
    - `updated_at` (ISO 8601 datetime) - Last modification timestamp
- `total_count` (integer) - Total number of tasks matching filter (ignoring limit/offset)
  - Rationale: Allows agent to say "You have 15 pending tasks, showing first 10"
- `filter_status` (string) - Echo of status filter used
- `limit` (integer) - Echo of limit parameter
- `offset` (integer) - Echo of offset parameter
- `has_more` (boolean) - True if there are additional results beyond current page
  - Calculation: `(offset + limit) < total_count`

**Validation Rules:**
- user_id must be valid and authenticated
- status must be one of: "all", "pending", "completed"
  - Case-insensitive matching allowed
- limit must be integer between 1 and 100
  - Values outside range should be clamped, not rejected
- offset must be integer >= 0
- sort_by must be one of the allowed fields
- sort_order must be "asc" or "desc"

**Error Cases:**
- **ValidationError** (400): When status is invalid enum value
  - Message: "Invalid status filter. Must be 'all', 'pending', or 'completed'"
- **ValidationError** (400): When limit is not an integer or out of range
  - Message: "Limit must be between 1 and 100"
- **ValidationError** (400): When offset is negative
  - Message: "Offset must be 0 or greater"
- **AuthorizationError** (401): When user_id doesn't match authenticated user
- **DatabaseError** (500): When query fails (safe to retry)

**Example:**
```json
// Input - Default (pending tasks)
{
  "user_id": "user_abc123"
}

// Output
{
  "tasks": [
    {
      "task_id": 43,
      "title": "Prepare presentation for Monday",
      "description": "Include Q3 sales figures and market analysis",
      "completed": false,
      "created_at": "2025-12-18T10:35:00Z",
      "updated_at": "2025-12-18T10:35:00Z"
    },
    {
      "task_id": 42,
      "title": "Buy groceries",
      "description": null,
      "completed": false,
      "created_at": "2025-12-18T10:30:00Z",
      "updated_at": "2025-12-18T10:30:00Z"
    }
  ],
  "total_count": 2,
  "filter_status": "pending",
  "limit": 50,
  "offset": 0,
  "has_more": false
}

// Agent Response
"Here are your pending tasks:
1. Prepare presentation for Monday
2. Buy groceries"
```

```json
// Input - Completed tasks only
{
  "user_id": "user_abc123",
  "status": "completed",
  "limit": 10
}

// Output
{
  "tasks": [
    {
      "task_id": 40,
      "title": "Submit assignment",
      "description": null,
      "completed": true,
      "created_at": "2025-12-17T14:00:00Z",
      "updated_at": "2025-12-18T09:00:00Z"
    },
    {
      "task_id": 38,
      "title": "Book hotel",
      "description": "Marriott downtown, Dec 25-27",
      "completed": true,
      "created_at": "2025-12-16T11:00:00Z",
      "updated_at": "2025-12-17T16:30:00Z"
    }
  ],
  "total_count": 2,
  "filter_status": "completed",
  "limit": 10,
  "offset": 0,
  "has_more": false
}

// Agent Response
"Here are your completed tasks:
1. ✓ Submit assignment
2. ✓ Book hotel"
```

```json
// Input - All tasks with pagination
{
  "user_id": "user_abc123",
  "status": "all",
  "limit": 5,
  "offset": 0
}

// Output (assuming user has 12 total tasks)
{
  "tasks": [ /* 5 task objects */ ],
  "total_count": 12,
  "filter_status": "all",
  "limit": 5,
  "offset": 0,
  "has_more": true
}

// Agent Response
"You have 12 tasks total. Here are the first 5:
..."
```

**Security Notes:**
- **CRITICAL:** ALWAYS include `WHERE user_id = ?` in SQL query to prevent data leakage
  - Use parameterized queries to prevent SQL injection
- Verify user_id from request matches JWT token user_id before query execution
- Rate limiting: Max 100 list requests per user per minute to prevent enumeration attacks
- Do not expose task_id patterns that could reveal information about other users
- Consider adding query logging for security audits (without logging task content)

**Idempotency:** Yes - calling multiple times with identical parameters returns consistent results (assuming no concurrent modifications by other requests)

**Natural Language Integration Notes:**
- Agent should interpret various phrasings:
  - "Show my tasks" → status="pending" (default)
  - "What do I need to do?" → status="pending"
  - "Show completed tasks" → status="completed"
  - "Show all tasks" → status="all"
  - "List everything" → status="all"
- For empty results, agent should respond conversationally:
  - No pending tasks: "You're all caught up! No pending tasks."
  - No completed tasks: "You haven't completed any tasks yet."

**Performance Optimization:**
- Index on (user_id, completed) for fast filtering
- Index on (user_id, created_at DESC) for default sort
- Consider materialized view for frequently accessed queries
- Use database connection pooling for concurrent requests

---

### Tool: update_task

**Purpose:** Modify the title and/or description of an existing task

**Parameters:**
- `user_id` (string, required) - User identifier from JWT token
- `task_id` (integer, required) - Unique identifier of task to update
- `title` (string, optional, 1-200 chars) - New task title (if provided, replaces existing title)
- `description` (string, optional, 0-1000 chars) - New description
  - If provided with content: Replaces existing description
  - If provided as empty string: Clears description (sets to null)
  - If omitted: Description unchanged

**Returns:**
- `task_id` (integer) - ID of updated task (echo for confirmation)
- `status` (string: "updated") - Operation status
- `title` (string) - Current title after update
- `description` (string|null) - Current description after update (null if cleared)
- `completed` (boolean) - Completion status (unchanged by this operation)
- `updated_at` (ISO 8601 datetime) - New update timestamp
- `changes` (object) - Summary of what changed
  - `title_changed` (boolean) - True if title was modified
  - `description_changed` (boolean) - True if description was modified

**Validation Rules:**
- user_id must own the task (verified via database query)
- task_id must exist in database
- At least one of `title` or `description` must be provided
  - Rationale: Update with no changes is invalid request
- Title (if provided) must be 1-200 characters, not whitespace-only
- Description (if provided) must be 0-1000 characters
- Empty string for description is valid (clears the description)
- Cannot change user_id (security constraint)
- Cannot change task_id (integrity constraint)
- Cannot change completed status (use complete_task tool instead)
  - Rationale: Separating concerns makes agent logic clearer

**Error Cases:**
- **ValidationError** (400): When no fields provided for update
  - Message: "No fields to update. Provide title, description, or both"
- **ValidationError** (400): When title validation fails (empty, too long, whitespace-only)
  - Message: "Title must be between 1 and 200 characters and cannot be empty"
- **ValidationError** (400): When description exceeds 1000 characters
  - Message: "Description cannot exceed 1000 characters"
- **NotFoundError** (404): When task_id doesn't exist in database
  - Message: "Task with ID {task_id} not found"
- **AuthorizationError** (403): When user_id doesn't own the task
  - Message: "You don't have permission to update this task"
  - Note: Return 403, not 404, to distinguish auth failure from missing resource
- **DatabaseError** (500): When update operation fails (safe to retry)

**Example:**
```json
// Input - Update title only
{
  "user_id": "user_abc123",
  "task_id": 42,
  "title": "Buy groceries and cook dinner"
}

// Output
{
  "task_id": 42,
  "status": "updated",
  "title": "Buy groceries and cook dinner",
  "description": null,
  "completed": false,
  "updated_at": "2025-12-18T11:45:00Z",
  "changes": {
    "title_changed": true,
    "description_changed": false
  }
}

// Agent Response
"I've updated the task to 'Buy groceries and cook dinner'."
```

```json
// Input - Add description to existing task
{
  "user_id": "user_abc123",
  "task_id": 42,
  "description": "Need milk, eggs, bread, and chicken. Then make pasta for dinner."
}

// Output
{
  "task_id": 42,
  "status": "updated",
  "title": "Buy groceries and cook dinner",
  "description": "Need milk, eggs, bread, and chicken. Then make pasta for dinner.",
  "completed": false,
  "updated_at": "2025-12-18T11:50:00Z",
  "changes": {
    "title_changed": false,
    "description_changed": true
  }
}

// Agent Response
"I've added the description to 'Buy groceries and cook dinner'."
```

```json
// Input - Clear description (empty string)
{
  "user_id": "user_abc123",
  "task_id": 42,
  "description": ""
}

// Output
{
  "task_id": 42,
  "status": "updated",
  "title": "Buy groceries and cook dinner",
  "description": null,
  "completed": false,
  "updated_at": "2025-12-18T11:55:00Z",
  "changes": {
    "title_changed": false,
    "description_changed": true
  }
}

// Agent Response
"I've removed the description from 'Buy groceries and cook dinner'."
```

```json
// Error - Task not found
{
  "user_id": "user_abc123",
  "task_id": 999,
  "title": "New title"
}

// Error Output
{
  "error": "NotFoundError",
  "message": "Task with ID 999 not found",
  "task_id": 999
}

// Agent Response
"I couldn't find that task. Can you show me your task list to select the right one?"
```

```json
// Error - Authorization failure
{
  "user_id": "user_abc123",
  "task_id": 55,
  "title": "Hacked title"
}

// Error Output (task 55 belongs to different user)
{
  "error": "AuthorizationError",
  "message": "You don't have permission to update this task",
  "task_id": 55
}

// Agent Response
"That task doesn't belong to you. I can only modify your own tasks."
```

**Security Notes:**
- **CRITICAL:** Verify task belongs to user_id before updating
  - SQL: `UPDATE tasks SET ... WHERE id = ? AND user_id = ?`
- Do not allow changing user_id field (would enable task theft)
- Do not allow changing task_id field (would enable overwriting other tasks)
- Sanitize title and description to prevent XSS
- Log all updates for audit trail (user_id, task_id, old_values, new_values, timestamp)
- Consider implementing version field for optimistic locking if concurrent updates are concern

**Idempotency:** Partial - calling twice with same values updates `updated_at` each time, but final data state is identical. For most purposes, can be treated as idempotent.

**Natural Language Integration Notes:**
- Agent should extract task identification and new values:
  - "Change 'buy groceries' to 'buy groceries and cook dinner'" → Find task by title, update title
  - "Update task 1 description to 'urgent'" → Update by task_id
  - "Rename 'call dentist' to 'call dentist at 3pm'" → Find by title, update title
- For ambiguous task references (multiple tasks with similar titles), agent should ask for clarification:
  - "I found 2 tasks with 'groceries' in the title. Which one do you want to update?"

**Database Query Pattern:**
```sql
-- Step 1: Verify ownership
SELECT id FROM tasks WHERE id = ? AND user_id = ?;

-- Step 2: Update if authorized
UPDATE tasks
SET
  title = COALESCE(?, title),
  description = CASE WHEN ? IS PROVIDED THEN ? ELSE description END,
  updated_at = CURRENT_TIMESTAMP
WHERE id = ? AND user_id = ?
RETURNING *;
```

---

### Tool: delete_task

**Purpose:** Permanently remove a task from the database (hard delete)

**Parameters:**
- `user_id` (string, required) - User identifier from JWT token
- `task_id` (integer, required) - Unique identifier of task to delete

**Returns:**
- `task_id` (integer) - ID of deleted task (echo for confirmation)
- `status` (string: "deleted") - Operation status
- `title` (string) - Title of deleted task (for agent confirmation message)
- `deleted_at` (ISO 8601 datetime) - Timestamp of deletion

**Validation Rules:**
- user_id must own the task (verified via database query)
- task_id must exist at time of deletion attempt
- Deletion is permanent and irreversible (no soft delete)
  - Rationale: Phase 3 spec doesn't require soft delete; keep simple

**Error Cases:**
- **NotFoundError** (404): When task_id doesn't exist
  - Message: "Task with ID {task_id} not found"
  - Note: Return same response whether task never existed or was already deleted (idempotent behavior)
- **AuthorizationError** (403): When user_id doesn't own the task
  - Message: "You don't have permission to delete this task"
- **DatabaseError** (500): When delete operation fails (safe to retry)

**Example:**
```json
// Input
{
  "user_id": "user_abc123",
  "task_id": 42
}

// Output (Success)
{
  "task_id": 42,
  "status": "deleted",
  "title": "Buy groceries",
  "deleted_at": "2025-12-18T12:00:00Z"
}

// Agent Response
"I've removed 'Buy groceries' from your task list."
```

```json
// Input (Delete already-deleted task - Idempotent)
{
  "user_id": "user_abc123",
  "task_id": 42
}

// Output (Same as success, idempotent behavior)
{
  "task_id": 42,
  "status": "deleted",
  "title": "Buy groceries",
  "deleted_at": "2025-12-18T12:00:00Z"
}

// Agent Response
"That task was already removed."
```

```json
// Error - Authorization failure
{
  "user_id": "user_abc123",
  "task_id": 55
}

// Error Output (task 55 belongs to different user)
{
  "error": "AuthorizationError",
  "message": "You don't have permission to delete this task",
  "task_id": 55
}

// Agent Response
"That task doesn't belong to you. I can only delete your own tasks."
```

**Security Notes:**
- **CRITICAL:** Verify task belongs to user_id before deleting
  - SQL: `DELETE FROM tasks WHERE id = ? AND user_id = ? RETURNING *`
- Log deletions for audit trail (user_id, task_id, title, timestamp)
  - Consider separate audit table: audit_log(user_id, action, resource_type, resource_id, timestamp)
- Rate limiting: Max 100 deletions per user per hour (prevent abuse)
- Consider implementing soft delete in future for data recovery:
  - Add `deleted` boolean column
  - Modify list_tasks to filter out deleted tasks
  - Add admin endpoint to recover deleted tasks

**Idempotency:** Yes - deleting an already-deleted task returns success (HTTP 200), not error (HTTP 404). This prevents errors in retry scenarios and simplifies agent logic.

**Implementation Pattern for Idempotency:**
```python
# Approach 1: Cache deleted task info briefly (15 minutes)
# When task deleted, store task info in Redis with TTL
# On subsequent delete attempts within TTL, return cached info
# After TTL expires, return generic "already deleted" response

# Approach 2: Keep deletion log table
# When task deleted, insert record into deletions table
# On subsequent delete attempts, check deletions table
# Return info from deletions table if found
```

**Natural Language Integration Notes:**
- Agent should extract task identification:
  - "Delete task 42" → task_id=42
  - "Remove 'buy groceries'" → Find task by title match, get task_id
  - "Cancel that task" → Use conversation context to identify most recently mentioned task
- For ambiguous task references, agent should ask for clarification:
  - "I found 2 tasks with 'groceries' in the title. Which one do you want to delete?"
- Agent should confirm before deleting (optional safeguard):
  - User: "Delete buy groceries"
  - Agent: "Are you sure you want to delete 'Buy groceries'? This can't be undone."
  - User: "Yes"
  - Agent: *calls delete_task tool*

**Database Query Pattern:**
```sql
-- Step 1: Get task info before deletion (for response)
SELECT id, title FROM tasks WHERE id = ? AND user_id = ?;

-- Step 2: Delete task
DELETE FROM tasks WHERE id = ? AND user_id = ?;

-- Alternative: Single query with RETURNING clause
DELETE FROM tasks
WHERE id = ? AND user_id = ?
RETURNING id, title, NOW() as deleted_at;
```

---

### Tool: complete_task

**Purpose:** Mark a task as completed or reopen a completed task (toggle completion status)

**Parameters:**
- `user_id` (string, required) - User identifier from JWT token
- `task_id` (integer, required) - Unique identifier of task to update
- `completed` (boolean, optional) - Desired completion status
  - Default: true (mark as complete)
  - Set to false to reopen a completed task
  - Rationale: Most common use case is marking complete; reopening is less frequent

**Returns:**
- `task_id` (integer) - ID of updated task
- `status` (string: "completed" | "reopened") - Operation status based on completed value
- `title` (string) - Task title for agent confirmation message
- `description` (string|null) - Task description for context
- `completed` (boolean) - New completion status
- `updated_at` (ISO 8601 datetime) - Timestamp of status change
- `completed_at` (ISO 8601 datetime|null) - Timestamp when marked complete (null if reopened)
  - Note: Requires adding completed_at column to database schema

**Validation Rules:**
- user_id must own the task (verified via database query)
- task_id must exist in database
- completed must be boolean (true or false)
- Marking already-completed task as complete is valid (idempotent)
- Reopening already-pending task is valid (idempotent)

**Error Cases:**
- **ValidationError** (400): When completed is not a boolean
  - Message: "Completed must be true or false"
- **NotFoundError** (404): When task_id doesn't exist
  - Message: "Task with ID {task_id} not found"
- **AuthorizationError** (403): When user_id doesn't own the task
  - Message: "You don't have permission to update this task"
- **DatabaseError** (500): When update operation fails (safe to retry)

**Example:**
```json
// Input - Mark task as complete (default)
{
  "user_id": "user_abc123",
  "task_id": 42
}

// Output
{
  "task_id": 42,
  "status": "completed",
  "title": "Buy groceries",
  "description": null,
  "completed": true,
  "updated_at": "2025-12-18T14:30:00Z",
  "completed_at": "2025-12-18T14:30:00Z"
}

// Agent Response
"Great! I've marked 'Buy groceries' as complete."
```

```json
// Input - Mark task as complete (explicit)
{
  "user_id": "user_abc123",
  "task_id": 43,
  "completed": true
}

// Output
{
  "task_id": 43,
  "status": "completed",
  "title": "Prepare presentation for Monday",
  "description": "Include Q3 sales figures and market analysis",
  "completed": true,
  "updated_at": "2025-12-18T14:35:00Z",
  "completed_at": "2025-12-18T14:35:00Z"
}

// Agent Response
"Awesome! I've marked 'Prepare presentation for Monday' as complete."
```

```json
// Input - Reopen completed task
{
  "user_id": "user_abc123",
  "task_id": 42,
  "completed": false
}

// Output
{
  "task_id": 42,
  "status": "reopened",
  "title": "Buy groceries",
  "description": null,
  "completed": false,
  "updated_at": "2025-12-18T14:40:00Z",
  "completed_at": null
}

// Agent Response
"I've reopened 'Buy groceries' and moved it back to your pending tasks."
```

```json
// Input - Mark already-completed task as complete (Idempotent)
{
  "user_id": "user_abc123",
  "task_id": 42,
  "completed": true
}

// Output (Same as first completion, but updated_at changes)
{
  "task_id": 42,
  "status": "completed",
  "title": "Buy groceries",
  "description": null,
  "completed": true,
  "updated_at": "2025-12-18T14:45:00Z",
  "completed_at": "2025-12-18T14:30:00Z"  // Original completion time preserved
}

// Agent Response
"That task is already marked as complete."
```

**Security Notes:**
- **CRITICAL:** Verify task belongs to user_id before updating
  - SQL: `UPDATE tasks SET completed = ? WHERE id = ? AND user_id = ?`
- Log all status changes for productivity analytics (optional feature for Phase 4)
- Consider adding completed_at timestamp field for better analytics
  - Track when tasks are completed (not just that they are)
  - Enables features like "You completed 5 tasks today!"

**Idempotency:** Yes - marking an already-completed task as complete returns success with unchanged state. This prevents errors in retry scenarios and matches user mental model ("just make sure it's marked complete").

**Natural Language Integration Notes:**
- Agent should interpret various phrasings for completion:
  - "Mark 'buy groceries' as done" → completed=true
  - "I finished calling the dentist" → completed=true
  - "Complete task 1" → completed=true
  - "I did the shopping" → completed=true (requires context to identify task)
  - "Check off buy groceries" → completed=true
- Agent should interpret various phrasings for reopening:
  - "Reopen 'buy groceries'" → completed=false
  - "I didn't finish that yet" → completed=false
  - "Undo completion of task 1" → completed=false
  - "Mark 'buy groceries' as pending" → completed=false
- For ambiguous task references, agent should ask for clarification
- Consider implementing batch completion in future:
  - "Mark all pending tasks as complete"
  - Requires new tool: complete_tasks_batch

**Database Schema Enhancement:**
```sql
ALTER TABLE tasks
ADD COLUMN completed_at TIMESTAMP NULL;

-- Migration: Set completed_at for already-completed tasks
UPDATE tasks
SET completed_at = updated_at
WHERE completed = TRUE AND completed_at IS NULL;
```

**Database Query Pattern:**
```sql
-- Mark complete
UPDATE tasks
SET
  completed = TRUE,
  completed_at = CURRENT_TIMESTAMP,
  updated_at = CURRENT_TIMESTAMP
WHERE id = ? AND user_id = ?
RETURNING *;

-- Reopen
UPDATE tasks
SET
  completed = FALSE,
  completed_at = NULL,
  updated_at = CURRENT_TIMESTAMP
WHERE id = ? AND user_id = ?
RETURNING *;
```

---

## Database Schema Requirements

### Tables

**tasks**
```sql
CREATE TABLE tasks (
  id SERIAL PRIMARY KEY,
  user_id VARCHAR(255) NOT NULL,
  title VARCHAR(200) NOT NULL,
  description TEXT NULL,
  completed BOOLEAN NOT NULL DEFAULT FALSE,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  completed_at TIMESTAMP NULL,

  -- Constraints
  CONSTRAINT tasks_title_not_empty CHECK (LENGTH(TRIM(title)) > 0),
  CONSTRAINT tasks_title_length CHECK (LENGTH(title) <= 200),
  CONSTRAINT tasks_description_length CHECK (description IS NULL OR LENGTH(description) <= 1000),

  -- Foreign key (assumes users table exists)
  CONSTRAINT fk_tasks_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
```

**Indexes**
```sql
-- User isolation (most important - used by all queries)
CREATE INDEX idx_tasks_user_id ON tasks(user_id);

-- Filtering by completion status
CREATE INDEX idx_tasks_user_completed ON tasks(user_id, completed);

-- Sorting by creation date (default sort)
CREATE INDEX idx_tasks_user_created ON tasks(user_id, created_at DESC);

-- Sorting by update date
CREATE INDEX idx_tasks_user_updated ON tasks(user_id, updated_at DESC);

-- Full-text search on title (optional, for future search feature)
CREATE INDEX idx_tasks_title_search ON tasks USING gin(to_tsvector('english', title));
```

**Triggers**
```sql
-- Auto-update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
   NEW.updated_at = CURRENT_TIMESTAMP;
   RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_tasks_updated_at
BEFORE UPDATE ON tasks
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();
```

---

## MCP Server Implementation Guide

### Python MCP Server Skeleton
```python
from mcp.server import MCPServer
from mcp.types import Tool, TextContent
from sqlmodel import Session, select
from database import engine, Task
from datetime import datetime

server = MCPServer("todo-mcp-server")

@server.tool("add_task")
async def add_task(user_id: str, title: str, description: str = None) -> dict:
    """Create a new task for the authenticated user"""
    # Validation
    if not title or not title.strip():
        raise ValueError("Title cannot be empty")
    if len(title) > 200:
        raise ValueError("Title cannot exceed 200 characters")
    if description and len(description) > 1000:
        raise ValueError("Description cannot exceed 1000 characters")

    # Create task
    with Session(engine) as session:
        task = Task(
            user_id=user_id,
            title=title.strip(),
            description=description.strip() if description else None,
            completed=False
        )
        session.add(task)
        session.commit()
        session.refresh(task)

        return {
            "task_id": task.id,
            "status": "created",
            "title": task.title,
            "description": task.description,
            "completed": task.completed,
            "created_at": task.created_at.isoformat()
        }

@server.tool("list_tasks")
async def list_tasks(
    user_id: str,
    status: str = "pending",
    limit: int = 50,
    offset: int = 0,
    sort_by: str = "created_at",
    sort_order: str = "desc"
) -> dict:
    """Retrieve tasks for the authenticated user with filtering"""
    # Implementation
    pass

@server.tool("update_task")
async def update_task(
    user_id: str,
    task_id: int,
    title: str = None,
    description: str = None
) -> dict:
    """Modify task title and/or description"""
    # Implementation
    pass

@server.tool("delete_task")
async def delete_task(user_id: str, task_id: int) -> dict:
    """Permanently remove a task"""
    # Implementation
    pass

@server.tool("complete_task")
async def complete_task(user_id: str, task_id: int, completed: bool = True) -> dict:
    """Toggle task completion status"""
    # Implementation
    pass

if __name__ == "__main__":
    server.run()
```

### SQLModel Schema
```python
from sqlmodel import SQLModel, Field
from datetime import datetime
from typing import Optional

class Task(SQLModel, table=True):
    __tablename__ = "tasks"

    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: str = Field(index=True, foreign_key="users.id")
    title: str = Field(max_length=200, min_length=1)
    description: Optional[str] = Field(default=None, max_length=1000)
    completed: bool = Field(default=False)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
    completed_at: Optional[datetime] = Field(default=None)
```

---

## OpenAI Agent Configuration

### Agent System Prompt
```python
agent_prompt = """
You are a friendly task management assistant. Help users manage their tasks through natural conversation.

**Available Tools:**
- add_task: Create new tasks
- list_tasks: View tasks (pending, completed, or all)
- update_task: Modify task title or description
- delete_task: Remove tasks permanently
- complete_task: Mark tasks as done or reopen them

**Guidelines:**
1. Extract task details from natural language input
2. Always confirm actions with friendly messages
3. Include task title in confirmation messages
4. Handle errors gracefully without exposing technical details
5. If user intent is unclear, ask clarifying questions
6. For task references, try to match by title or accept task IDs

**Examples:**
User: "Add a task to buy groceries"
You: *call add_task(title="Buy groceries")* → "I've added 'Buy groceries' to your task list."

User: "What do I need to do?"
You: *call list_tasks(status="pending")* → "Here are your pending tasks: 1. Buy groceries, 2. Call dentist"

User: "I finished buying groceries"
You: *call complete_task(title="Buy groceries")* → "Great! I've marked 'Buy groceries' as complete."
"""
```

### Agent Creation
```python
from openai import OpenAI

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

agent = client.beta.agents.create(
    name="Todo Task Manager",
    model="gpt-4o-mini",
    instructions=agent_prompt,
    tools=[
        {
            "type": "mcp_server",
            "mcp_server": {
                "url": "http://localhost:8000/mcp",
                "name": "todo-mcp-server"
            }
        }
    ]
)
```

---

## Testing Strategy

### Unit Tests (Per Tool)
```python
# tests/test_add_task.py
def test_add_task_success():
    result = add_task("user_123", "Buy groceries")
    assert result["status"] == "created"
    assert result["title"] == "Buy groceries"
    assert result["completed"] == False

def test_add_task_empty_title():
    with pytest.raises(ValueError, match="Title cannot be empty"):
        add_task("user_123", "   ")

def test_add_task_title_too_long():
    with pytest.raises(ValueError, match="Title cannot exceed 200 characters"):
        add_task("user_123", "a" * 201)

def test_add_task_with_description():
    result = add_task("user_123", "Buy groceries", "Milk, eggs, bread")
    assert result["description"] == "Milk, eggs, bread"
```

### Integration Tests (End-to-End)
```python
# tests/test_chat_integration.py
def test_create_and_complete_task_flow():
    # Create task
    response1 = chat_endpoint(user_id="user_123", message="Add a task to buy groceries")
    assert "Buy groceries" in response1["response"]

    # List tasks
    response2 = chat_endpoint(user_id="user_123", message="Show my tasks")
    assert "Buy groceries" in response2["response"]

    # Complete task
    response3 = chat_endpoint(user_id="user_123", message="Mark buy groceries as done")
    assert "complete" in response3["response"].lower()

    # Verify completion
    response4 = chat_endpoint(user_id="user_123", message="Show completed tasks")
    assert "Buy groceries" in response4["response"]
```

### Natural Language Tests
```python
# tests/test_natural_language.py
def test_add_task_variations():
    variations = [
        ("Add a task to buy groceries", "Buy groceries"),
        ("I need to call the dentist", "Call the dentist"),
        ("Remind me to submit the report", "Submit the report"),
        ("Create task: prepare presentation", "Prepare presentation")
    ]

    for input_msg, expected_title in variations:
        response = chat_endpoint("user_123", input_msg)
        # Verify task was created with correct title
        assert expected_title.lower() in response["response"].lower()
```

---

## Performance Considerations

### Query Optimization
- Use indexes on user_id for all queries
- Use composite indexes for filtered queries (user_id, completed)
- Limit result sets (max 100 rows)
- Use database connection pooling

### Caching Strategy
- Cache user's pending task count (invalidate on add/delete/complete)
- Cache recent conversations (15-minute TTL)
- Do NOT cache task content (staleness risk)

### Rate Limiting
- Per-user limits:
  - add_task: 100/hour
  - list_tasks: 100/minute
  - update_task: 100/hour
  - delete_task: 100/hour
  - complete_task: 100/hour
- Implement using Redis with sliding window

---

## Security Checklist

- [ ] All tools validate user_id ownership before operations
- [ ] JWT tokens validated at API gateway level
- [ ] Parameterized SQL queries prevent injection
- [ ] HTML entity escaping prevents XSS
- [ ] Rate limiting prevents abuse
- [ ] Authorization errors return 403 (not 404 for enumeration prevention)
- [ ] Database credentials in environment variables
- [ ] Audit logging for all data modifications
- [ ] No sensitive data in logs (task content omitted)

---

## Deployment Considerations

### Environment Variables
```bash
DATABASE_URL=postgresql://user:pass@host:5432/dbname
OPENAI_API_KEY=sk-...
BETTER_AUTH_SECRET=secret-key
MCP_SERVER_PORT=8000
LOG_LEVEL=INFO
RATE_LIMIT_ENABLED=true
```

### Health Check Endpoint
```python
@app.get("/health")
def health_check():
    # Check database connection
    # Check MCP server status
    return {"status": "healthy", "timestamp": datetime.utcnow()}
```

---

## Future Enhancements (Phase 4+)

1. **Batch Operations**
   - complete_tasks_batch: Mark multiple tasks complete at once
   - delete_tasks_batch: Delete multiple tasks at once

2. **Search Tool**
   - search_tasks: Full-text search on title and description
   - Parameters: query, status filter, limit, offset

3. **Advanced Filters**
   - Filter by date range (created_at, updated_at, completed_at)
   - Filter by keyword in title/description

4. **Soft Delete**
   - Add deleted boolean column
   - recover_task tool to restore deleted tasks
   - Permanent deletion after 30 days

5. **Task Analytics**
   - get_task_stats: Completion rate, tasks per day, average completion time
   - Requires completed_at timestamp field

---

**MCP Tool Architecture Complete**
**Ready for Implementation Phase**
**Estimated Development Time: 8-12 hours**
